#include <iostream>
#include <string>
#include <utility>
#include <algorithm>

using namespace std;

int char2int ( char c )
{
	switch ( c )
	{
		case 'A':
			return 0;
		case 'C':
			return 1;
		case 'G':
			return 2;
		case 'T':
			return 3;
		default:
			return 4;
	}
}

bool same_pair ( pair<int,int> &a, pair<int,int> &b )
{
	if ( a.first == b.first && a.second == b.second )
		return true;
	else
		return false;
}

struct comparator 
{
	const vector < pair<int,int> > & value_vector;
	comparator( const vector < pair<int,int> > & val_vec ):
		value_vector(val_vec){}

	bool operator() ( int i1, int i2 )
	{
		if ( value_vector[i1].first == value_vector[i2].first )
			return value_vector[i1].second < value_vector[i2].second;
		else
			return value_vector[i1].first < value_vector[i2].first;
	}
};

void Rank_index ( string & sq, int n, vector< vector<int> > & rank, int level )
{
	rank[0].resize(n);
	for ( int i = 0; i < n; i++ )
	{
		rank[0][i] = char2int ( sq[i] );
	}

	for ( int k = 1; k < level; k++ ) 
	{
		int l = pow ( 2, k );
		rank[k].resize( n-l+1 );
		vector< int > sort_for_rank ( n-l+1 );
		vector< pair<int,int> > pair_cover ( n-l+1 );
		for ( int i = 0; i < n-l+1; i++ )
		{
			sort_for_rank[i] = i;
			pair<int, int> p ( rank[k-1][i], rank[k-1][i+ l/2] );
			pair_cover[i] = p;
		}
		sort ( sort_for_rank.begin(), sort_for_rank.end(), comparator(pair_cover) );
		int j = 0;
		for ( int i = 0; i < n-l+1; i++ )
		{
			if ( i > 0 )
			{
				if ( same_pair ( pair_cover[sort_for_rank[i-1]], pair_cover[sort_for_rank[i]] ) )
					j--;
			}
			rank[k][sort_for_rank[i]] = j;
			j++;
		}
	}
}


